/* automatically generated by rust-bindgen */

pub const LIBLINEAR_VERSION: ::std::os::raw::c_uint = 220;
extern "C" {
    #[link_name = "liblinear_version"]
    pub static mut liblinear_version: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct feature_node {
    pub index: ::std::os::raw::c_int,
    pub value: f64,
}
#[test]
fn bindgen_test_layout_feature_node() {
    assert_eq!(::std::mem::size_of::<feature_node>() , 16usize , concat ! (
               "Size of: " , stringify ! ( feature_node ) ));
    assert_eq! (::std::mem::align_of::<feature_node>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( feature_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const feature_node ) ) . index as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( feature_node ) , "::" ,
                stringify ! ( index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const feature_node ) ) . value as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( feature_node ) , "::" ,
                stringify ! ( value ) ));
}
impl Clone for feature_node {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct problem {
    pub l: ::std::os::raw::c_int,
    pub n: ::std::os::raw::c_int,
    pub y: *mut f64,
    pub x: *mut *mut feature_node,
    pub bias: f64,
}
#[test]
fn bindgen_test_layout_problem() {
    assert_eq!(::std::mem::size_of::<problem>() , 32usize , concat ! (
               "Size of: " , stringify ! ( problem ) ));
    assert_eq! (::std::mem::align_of::<problem>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( problem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const problem ) ) . l as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( problem ) , "::" ,
                stringify ! ( l ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const problem ) ) . n as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( problem ) , "::" ,
                stringify ! ( n ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const problem ) ) . y as * const _ as usize } ,
                8usize , concat ! (
                "Alignment of field: " , stringify ! ( problem ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const problem ) ) . x as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( problem ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const problem ) ) . bias as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( problem ) , "::" ,
                stringify ! ( bias ) ));
}
impl Clone for problem {
    fn clone(&self) -> Self { *self }
}
pub const L2R_LR: _bindgen_ty_1 = _bindgen_ty_1::L2R_LR;
pub const L2R_L2LOSS_SVC_DUAL: _bindgen_ty_1 =
    _bindgen_ty_1::L2R_L2LOSS_SVC_DUAL;
pub const L2R_L2LOSS_SVC: _bindgen_ty_1 = _bindgen_ty_1::L2R_L2LOSS_SVC;
pub const L2R_L1LOSS_SVC_DUAL: _bindgen_ty_1 =
    _bindgen_ty_1::L2R_L1LOSS_SVC_DUAL;
pub const MCSVM_CS: _bindgen_ty_1 = _bindgen_ty_1::MCSVM_CS;
pub const L1R_L2LOSS_SVC: _bindgen_ty_1 = _bindgen_ty_1::L1R_L2LOSS_SVC;
pub const L1R_LR: _bindgen_ty_1 = _bindgen_ty_1::L1R_LR;
pub const L2R_LR_DUAL: _bindgen_ty_1 = _bindgen_ty_1::L2R_LR_DUAL;
pub const L2R_L2LOSS_SVR: _bindgen_ty_1 = _bindgen_ty_1::L2R_L2LOSS_SVR;
pub const L2R_L2LOSS_SVR_DUAL: _bindgen_ty_1 =
    _bindgen_ty_1::L2R_L2LOSS_SVR_DUAL;
pub const L2R_L1LOSS_SVR_DUAL: _bindgen_ty_1 =
    _bindgen_ty_1::L2R_L1LOSS_SVR_DUAL;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    L2R_LR = 0,
    L2R_L2LOSS_SVC_DUAL = 1,
    L2R_L2LOSS_SVC = 2,
    L2R_L1LOSS_SVC_DUAL = 3,
    MCSVM_CS = 4,
    L1R_L2LOSS_SVC = 5,
    L1R_LR = 6,
    L2R_LR_DUAL = 7,
    L2R_L2LOSS_SVR = 11,
    L2R_L2LOSS_SVR_DUAL = 12,
    L2R_L1LOSS_SVR_DUAL = 13,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct parameter {
    pub solver_type: ::std::os::raw::c_int,
    pub eps: f64,
    pub C: f64,
    pub nr_weight: ::std::os::raw::c_int,
    pub weight_label: *mut ::std::os::raw::c_int,
    pub weight: *mut f64,
    pub p: f64,
    pub init_sol: *mut f64,
}
#[test]
fn bindgen_test_layout_parameter() {
    assert_eq!(::std::mem::size_of::<parameter>() , 64usize , concat ! (
               "Size of: " , stringify ! ( parameter ) ));
    assert_eq! (::std::mem::align_of::<parameter>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( parameter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const parameter ) ) . solver_type as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( parameter ) , "::" ,
                stringify ! ( solver_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const parameter ) ) . eps as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( parameter ) , "::" ,
                stringify ! ( eps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const parameter ) ) . C as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( parameter ) , "::" ,
                stringify ! ( C ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const parameter ) ) . nr_weight as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( parameter ) , "::" ,
                stringify ! ( nr_weight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const parameter ) ) . weight_label as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( parameter ) , "::" ,
                stringify ! ( weight_label ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const parameter ) ) . weight as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( parameter ) , "::" ,
                stringify ! ( weight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const parameter ) ) . p as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( parameter ) , "::" ,
                stringify ! ( p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const parameter ) ) . init_sol as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( parameter ) , "::" ,
                stringify ! ( init_sol ) ));
}
impl Clone for parameter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct model {
    pub param: parameter,
    pub nr_class: ::std::os::raw::c_int,
    pub nr_feature: ::std::os::raw::c_int,
    pub w: *mut f64,
    pub label: *mut ::std::os::raw::c_int,
    pub bias: f64,
}
#[test]
fn bindgen_test_layout_model() {
    assert_eq!(::std::mem::size_of::<model>() , 96usize , concat ! (
               "Size of: " , stringify ! ( model ) ));
    assert_eq! (::std::mem::align_of::<model>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( model ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const model ) ) . param as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( model ) , "::" ,
                stringify ! ( param ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const model ) ) . nr_class as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( model ) , "::" ,
                stringify ! ( nr_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const model ) ) . nr_feature as * const _ as
                usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( model ) , "::" ,
                stringify ! ( nr_feature ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const model ) ) . w as * const _ as usize } ,
                72usize , concat ! (
                "Alignment of field: " , stringify ! ( model ) , "::" ,
                stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const model ) ) . label as * const _ as usize }
                , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( model ) , "::" ,
                stringify ! ( label ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const model ) ) . bias as * const _ as usize }
                , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( model ) , "::" ,
                stringify ! ( bias ) ));
}
impl Clone for model {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn train(prob: *const problem, param: *const parameter) -> *mut model;
}
extern "C" {
    pub fn cross_validation(prob: *const problem, param: *const parameter,
                            nr_fold: ::std::os::raw::c_int, target: *mut f64);
}
extern "C" {
    pub fn find_parameter_C(prob: *const problem, param: *const parameter,
                            nr_fold: ::std::os::raw::c_int, start_C: f64,
                            max_C: f64, best_C: *mut f64,
                            best_rate: *mut f64);
}
extern "C" {
    pub fn predict_values(model_: *const model, x: *const feature_node,
                          dec_values: *mut f64) -> f64;
}
extern "C" {
    pub fn predict(model_: *const model, x: *const feature_node) -> f64;
}
extern "C" {
    pub fn predict_probability(model_: *const model, x: *const feature_node,
                               prob_estimates: *mut f64) -> f64;
}
extern "C" {
    pub fn save_model(model_file_name: *const ::std::os::raw::c_char,
                      model_: *const model) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn load_model(model_file_name: *const ::std::os::raw::c_char)
     -> *mut model;
}
extern "C" {
    pub fn get_nr_feature(model_: *const model) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_nr_class(model_: *const model) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_labels(model_: *const model,
                      label: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn get_decfun_coef(model_: *const model,
                           feat_idx: ::std::os::raw::c_int,
                           label_idx: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn get_decfun_bias(model_: *const model,
                           label_idx: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn free_model_content(model_ptr: *mut model);
}
extern "C" {
    pub fn free_and_destroy_model(model_ptr_ptr: *mut *mut model);
}
extern "C" {
    pub fn destroy_param(param: *mut parameter);
}
extern "C" {
    pub fn check_parameter(prob: *const problem, param: *const parameter)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn check_probability_model(model: *const model)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn check_regression_model(model: *const model)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_print_string_function(print_func:
                                         ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                        *const ::std::os::raw::c_char)>);
}
